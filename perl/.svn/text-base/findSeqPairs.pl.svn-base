#!/usr/bin/perl -w
use strict;
BEGIN {push @INC, $ENV{"SCRIPT_HOME_PERL"}};
use File::Path qw/make_path remove_tree/;
use Bio::Graphics;
use Bio::SeqFeature::Generic;
use Common;
use Seq;
use Align;
use Gene;
use Gtb;
use Draw;
use Data::Dumper;
use List::Util qw/min max sum/;
use List::MoreUtils qw/first_index last_index insert_after apply indexes pairwise zip uniq/;

my $dir_i = "/project/youngn/zhoup/Data/misc3/spada.crp/Athaliana";
my $f_pre = "$dir_i/31_model_SPADA/61_final.gtb";
my $f_ref = "$dir_i/01_genome/01_refseq.fa";
my $f_gtb = "$dir_i/01_genome/61_gene.gtb";

my $dir = "/project/youngn/zhoup/Data/misc2/crp.evo";
my $f01 = "$dir/01_seq.tbl";
#prepare_seq($f_pre, $f_ref, $dir);
my $f02 = "$dir/02_pairs.tbl";
#screen_pairs_raw($f01, $f02);
my $f03 = "$dir/03_yass.tbl";
#screen_pairs_yass($f01, $f02, $f03);
my $f04 = "$dir/04_yass_filtered.tbl";
#filter_yass($f03, $f04);
my $f09 = "$dir/09.tbl";
#prepare_plot($f01, $f04, $f09);
my $d11 = "$dir/11_figs";
comparative_plot($f09, $d11, $f_pre, $f_gtb);

sub run_yass {
    my ($seq1, $seq2) = @_;
    my $f_bin = "/project/youngn/zhoup/Source/yass-1.14/src/yass";
    my $fi1 = "yass_seq1_".int(rand(1000)).".fa";
    my $fi2 = "yass_seq2_".int(rand(1000)).".fa";
    my $fo = "yass_".int(rand(1000)).".txt";
    writeFile($fi1, ">seq1", $seq1);
    writeFile($fi2, ">seq2", $seq2);
    my $cmd = "$f_bin $fi1 $fi2 -d 2 -o $fo";
    runCmd($cmd, 0);

    my @ary;
    open(FH, "<$fo") or die "cannot open $fo for reading\n";
    while(<FH>) {
        chomp;
        next if /^\#/;
        my @ps = split /\s+/;
        next if $ps[0] ne "seq1" || $ps[1] ne "seq2";
        die "yass output not 12 fields:\n$_\n$cmd\n" if @ps != 12;
        push @ary, [@ps[2..11]];
    }
    close FH;

    system("rm $fi1 $fi2 $fo");
    return \@ary;
}
sub prepare_seq {
    my ($f_pre, $f_ref, $dir) = @_;
    my $t = readTable(-in=>$f_pre, -header=>1);

    my $fo = "$dir/01_seq.tbl";
    open(FHO, ">$fo") or die "cannot open $fo for writing\n";
    print FHO join("\t", qw/id fam chr beg end strand locC 
      seq_pro seq_cds seq_ext/)."\n";
    for my $i (0..$t->nofRow-1) {
        my ($id, $fam, $chr, $begM, $endM, $str, $locCS, $seq_pro) = 
          map {$t->elm($i, $_)} qw/id cat3 chr beg end strand locC seq/;
        my $locC = locStr2Ary($locCS);
        my $seq_cds = seqRet($locC, $chr, $str, $f_ref);

        my $beg = max(1, $begM-1000);
        my $end = min($endM+1000, seqLen($chr, $f_ref));
        $locC = [ sort {$a->[0] <=> $b->[0]} @$locC ];
        $locC = [ reverse @$locC ] if $str eq "-";
        my $locCR = $str eq "-" ?
          [ map {[$end-$_->[1]+1, $end-$_->[0]+1]} @$locC ] : 
          [ map {[$_->[0]-$beg+1, $_->[1]-$beg+1]} @$locC ];
        my $seq_ext = seqRet([[$beg, $end]], $chr, $str, $f_ref);
        print FHO join("\t", $id, $fam, $chr, $beg, $end, $str, locAry2Str($locCR),
          $seq_pro, $seq_cds, $seq_ext)."\n";
    }
    close FHO;
}
sub screen_pairs_raw {
    my ($fi, $fo) = @_;
    my $t = readTable(-in=>$fi, -header=>1);
    open(FHO, ">$fo") or die "cannot open $fo for writing\n";
    print FHO join("\t", qw/fam id1 id2 pct_idty/)."\n";

    my $h = group($t->colRef("fam"));
    for my $fam (sort(keys(%$h))) {
        my ($idx, $cnt) = @{$h->{$fam}};
        for my $i ($idx..$idx+$cnt-1) {
            for my $j ($i+1..$idx+$cnt-1) {
                my ($id1, $chr1, $beg1, $end1, $seq1) = 
                  map {$t->elm($i, $_)} qw/id chr beg end seq_cds/;
                my ($id2, $chr2, $beg2, $end2, $seq2) = 
                  map {$t->elm($j, $_)} qw/id chr beg end seq_cds/;
                next if ($chr1 eq $chr2 && abs($beg1-$beg2) < 100_000);
                my $seqO1 = Bio::Seq->new(-id=>$id1, -seq=>$seq1);
                my $seqO2 = Bio::Seq->new(-id=>$id2, -seq=>$seq2);
                my $aln = run_water($seqO1, $seqO2);
                my $pct_idty = sprintf "%.01f", $aln->percentage_identity();
                if($pct_idty > 70) {
                    print FHO join("\t", $fam, $id1, $id2, $pct_idty)."\n";
                }
            }
        }
    }
    close FHO;
}
sub screen_pairs_yass {
    my ($f01, $f02, $f03) = @_;
    
    my $hs;
    my $t1 = readTable(-in=>$f01, -header=>1);
    for my $i (0..$t1->nofRow-1) {
        my ($id, $locS, $seq_ext) = map {$t1->elm($i, $_)} qw/id locC seq_ext/;
        $hs->{$id} = [ locStr2Ary($locS), $seq_ext ];
    }

    open(FHO, ">$f03") or die "cannot open $f03 for writing\n";
    print FHO join("\t", qw/fam id1 id2 locC1 locC2 match/)."\n";

    my $t = readTable(-in=>$f02, -header=>1);
    for my $i (0..$t->nofRow-1) {
        my ($fam, $id1, $id2) = $t->row($i);
        my ($loc1, $seq1) = @{$hs->{$id1}};
        my ($loc2, $seq2) = @{$hs->{$id2}};

        my $ary = run_yass($seq1, $seq2);
        my @aryStr;
        for (@$ary) {
            my ($pct_idty, $len_aln, $mm, $gap, $b1, $e1, $b2, $e2, $e, $score) = @$_;
            my $str = ($e2 < $b2) ? "-" : "+";
            ($b2, $e2) = ($e2, $b2) if $str eq "-";
            push @aryStr, join("_", $b1, $e1, $str, $b2, $e2, $pct_idty/100, $e, $len_aln);
        }
        my $str = join(",", @aryStr);
        print FHO join("\t", $fam, $id1, $id2, locAry2Str($loc1), locAry2Str($loc2), $str)."\n";
    }
    close FHO;
}
sub filter_yass {
    my ($f03, $f04) = @_;
    my $t = readTable(-in=>$f03, -header=>1);

    open(FH, ">$f04") or die "cannot open $f04 for writing\n";
    print FH join("\t", qw/id fam id1 id2 locC1 locC2 match/)."\n";
    my $id = 0;
    for my $i (0..$t->nofRow-1) {
        my ($fam, $id1, $id2, $locS1, $locS2, $matchStr) = $t->row($i);
        my $loc1 = locStr2Ary($locS1);
        my $loc2 = locStr2Ary($locS2);

        my $flag = 0;
        my @ms = map {[split("_", $_)]} split(",", $matchStr);
        for (@ms) {
            my ($b1, $e1, $str, $b2, $e2, $pct, $e, $len) = @$_;
            next if $len < 50 || $e > 0.1 || $str eq "-";
            my ($locO1, $lenO1) = posOvlp($loc1, [[$b1, $e1]]);
            my ($locO2, $lenO2) = posOvlp($loc2, [[$b2, $e2]]);
            $flag = 1 if $lenO1 > 100 && $lenO2 > 100;
        }
        next if $flag == 0;

        $matchStr = join(",", map {join("_", @$_)} @ms);
        print FH join("\t", ++$id, $fam, $id1, $id2, $locS1, $locS2, $matchStr)."\n";
    }
    close FH;
}
sub prepare_plot {
    my ($f01, $f04, $f09) = @_;
    my $ts = readTable(-in=>$f01, -header=>1);
    my $hs = { map {$ts->elm($_, "id") => $ts->rowRef($_)} (0..$ts->nofRow-1) };
    my $t = readTable(-in=>$f04, -header=>1);

    open(FH, ">$f09") or die "cannot open $f04 for writing\n";
    print FH join("\t", qw/id fam id1 chr1 beg1 end1 str1 locC1 id2 chr2 beg2 end2 str2 locC2 match/)."\n";
    my $id = 0;
    for my $i (0..$t->nofRow-1) {
        my ($id, $fam, $id1, $id2, $locS1, $locS2, $matchStr) = $t->row($i);
        my ($chr1, $beg1, $end1, $str1) = @{$hs->{$id1}}[2..5];
        my ($chr2, $beg2, $end2, $str2) = @{$hs->{$id2}}[2..5];
        my $locCR1 = locStr2Ary($locS1);
        my $locCR2 = locStr2Ary($locS2);
        my $locC1 = $str1 eq "-" ? [ map {[$end1-$_->[1]+1, $end1-$_->[0]+1]} reverse(@$locCR1) ] : [ map {[$beg1+$_->[0]-1, $beg1+$_->[1]-1]} @$locCR1 ];
        my $locC2 = $str2 eq "-" ? [ map {[$end2-$_->[1]+1, $end2-$_->[0]+1]} reverse(@$locCR2) ] : [ map {[$beg2+$_->[0]-1, $beg2+$_->[1]-1]} @$locCR2 ];

        my @ps;
        for (split(",", $matchStr)) {
            my ($bl1, $el1, $strl, $bl2, $el2, $pct, $e, $len) = split("_", $_);
            my $strm1 = $str1 eq "+"   ? "+" : "-";
            my $strm2 = $str2 eq $strl ? "+" : "-";
            my ($bg1, $eg1) = $strm1 eq "+" ? ($beg1+$bl1-1, $beg1+$el1-1) : ($end1-$el1+1, $end1-$bl1+1);
            my ($bg2, $eg2) = $strm2 eq "+" ? ($beg2+$bl2-1, $beg2+$el2-1) : ($end2-$el2+1, $end2-$bl2+1);
            push @ps, join("_", $bg1, $eg1, $strm1, $bg2, $eg2, $strm2, $pct, $e, $len);
        }
        print FH join("\t", $id, $fam, $id1, $chr1, $beg1, $end1, $str1, locAry2Str($locC1), 
            $id2, $chr2, $beg2, $end2, $str2, locAry2Str($locC2), join(",", @ps))."\n";
    }
    close FH;
}

sub gtb2Feature {
    my ($tg, $chr, $beg, $end) = @_;
    my @fes;
    my $tg_r = $tg->match_pattern("\$_->[2] eq '$chr' &&
      ( (\$_->[3] > $beg && \$_->[3] < $end) || (\$_->[4] > $beg && \$_->[4] < $end) )");
    for my $i (0..$tg_r->nofRow-1) {
        my ($id, $str, $locCS, $locES, $loc5S, $loc3S) = map {$tg_r->elm($i, $_)} qw/id strand locC locE loc5 loc3/;
        my ($locC, $locE, $loc5, $loc3) = map {locStr2Ary($_)} ($locCS, $locES, $loc5S, $loc3S);
        my $fe = loc2Feature(-id=>$id, -strand=>$str, -locC=>$locC, -locE=>$locE);
        push @fes, $fe;
    }
    return \@fes;
}

sub comparative_plot {
    my ($f09, $d11, $f_pre, $f_gtb) = @_;
    make_path($d11) unless -d $d11;
    remove_tree($d11, {keep_root=>1});
    my $t = readTable(-in=>$f09, -header=>1);

    my $tp = readTable(-in=>$f_pre, -header=>1);
    my $hp = { map {$tp->elm($_, "id") => $tp->subTable([$_])} (0..$tp->nofRow-1) };
    my ($tg, $ref, $idGs) = gtbSum($f_gtb, 0);
  
    for my $i (0..$t->nofRow-1) {
        my ($id, $fam, $id1, $chr1, $beg1, $end1, $str1, $locS1, $id2, $chr2, $beg2, $end2, $str2, $locS2, $matchS) = $t->row($i);
        my ($loc1, $loc2) = (locStr2Ary($locS1), locStr2Ary($locS2));
        my @ms = map {[split("_", $_)]} split(",", $matchS);
        next if $i > 10;

        my $p1 = Bio::Graphics::Panel->new( -start=>$beg1, -end=>$end1, -width=>800, -pad_left=>10, -pad_right=>40, -key_style=>'between', -grid=>1 );
        my $fl1 = Bio::SeqFeature::Generic->new( -display_name=>$chr1, -start=>$beg1, -end=>$end1 );
        $p1->add_track($fl1, -glyph=>'arrow', -bump=>0, -double=>1, -tick=>1, -label=>1);
        
        my $fe1 = loc2Feature(-id=>$id, -locC=>$loc1, -strand=>$str1);
        $p1->add_track($fe1,
            -glyph       => 'processed_transcript',
            -height      => 10,
            -key         => 'SPADA_prediction',
            -bgcolor     => 'skyblue',
            -fgcolor     => 'slateblue',
            -connector   => 'solid',
            -label       => 1,
            -description => 0,
        ); 

        my $fes_gene_1 = gtb2Feature($tg, $chr1, $beg1, $end1);
        $p1->add_track($fes_gene_1,
            -glyph       => 'processed_transcript',
#            -height      => 10,
            -key         => 'Genome Annotation',
            -bgcolor     => 'orange',
            -fgcolor     => 'black',
            -connector   => 'solid',
            -label       => 1,
            -description => 0,
            -implied_utrs=> 1,
        ); 
        
        my @fes_aln_1;
        my @fes_aln_2;
        for my $k (1..@ms) {
            my ($b1, $e1, $str1, $b2, $e2, $str2, $pct, $e, $len) = @{$ms[$k-1]};
            my $fe_aln_1 = Bio::SeqFeature::Generic->new( -display_name=>"$id#$k", -start=>$b1, -end=>$e1, -strand=>$str1, -primary_tag=>'match', -score=>$pct );
            my $fe_aln_2 = Bio::SeqFeature::Generic->new( -display_name=>"$id#$k", -start=>$b2, -end=>$e2, -strand=>$str2, -primary_tag=>'match', -score=>$pct );
            push @fes_aln_1, $fe_aln_1;
            push @fes_aln_2, $fe_aln_2;
        }
 
        $p1->add_track(\@fes_aln_1,
            -glyph       => 'line',
#            -height      => 10,
            -key         => 'Hit',
            -bgcolor     => '',
            -fgcolor     => '',
            -connector   => 'solid',
            -label       => sub {my $fe = shift; return $fe->display_name." ".$fe->score},
            -description => 1,
            -strand_arrow=> 1,
        ); 
        
        my $fo = "$d11/$id.png";
        open(FH, ">$fo") or die "cannot open $fo for write\n";
        print FH $p1->png;
    }
}



